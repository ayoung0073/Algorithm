# 컴퓨터 알고리즘
## 2주차. 재귀 
### 재귀 알고리즘
- 알고리즘 자신을 사용하여 정의된 알고리즘(비재귀적 또는 반복적 알고리즘과 대조)
### 반복(iterative) VS  재귀(recursive)
|  |재귀|반복(비재귀)|
|---|---|---|
|기본|반복적으로 명령 실행|함수를 자체를 호출|
|체제|초기화, 조건, 루프 내 명령문 실행과 제어 변수 업데이트 포함|종료 조건만 지정(조건 추가될 수 있음)|
|종료|설정한 조건에 도달할 때까지 반복 실행|함수 호출 본문에 조건 포함, 재귀를 호출하지 않고 함수 강제 반환|
|조건|제어 조건이 참이면 무한 반복 발생|조건에 수렴하지 않으면 무한 재귀 발생|
|무한 반복|무한 루프는 CPU 사이클을 반복적으로 사용|스택 오버플로우 발생|
|스택 메모리|스택 메모리 사용 X|함수 호출될 때마다 새 로컬 변수와 매개 변수 집합, 함수 호출 위치를 저장하는 데 사용|
|속도|빠른 실행|느린 실행|
|가독성|코드 길이가 길어지고 변수가 많아져 가독성 ↓|코드 길이와 변수가 적어 가독성 ↑|
### 재귀의 요소
	- 재귀 케이스(**recursion**)
		차후의 재귀 호출은 **작아진 부문제들(subproblems)**을 대상으로 이루어진다.
	- 베이스 케이스(**base case**)
		부문제들이 충분히 작아지면, 알고리즘은 재귀를 사용하지 않고 직접 해결한다.
		
### 작동 원리
- 보류된 재귀호출(즉, 시작했지만 완료되지 않고 대기중인 호출들)을 위한 변수들에 관련된 저장/복구는 컴퓨터에 의해 자동적으로 수행
- **스택(stack)** : **LIFO**

### 기본 규칙
- 베이스 케이스 : 베이스 케이스를 항상 가져야 하며, 재귀없이 해결할 수 있어야 함.
- 진행 방향 : 재귀적으로 해결되어야 할 경우, 항상 베이스 케이스를 향하는 방향으로 진행.
- 정상작동 가정 : 모든 재귀 호출이 제대로 작동한다고 가정.
- 적절한 사용 : 꼭 **필요**할 때만 사용, 저장/복구 때문에 **성능 저하**되기 때문이다.



#### 재귀 함수를 사용하는 이유
1. 알고리즘 자체가 재귀적으로 표현하기 자연스러울 때(가독성)
2. 변수 사용을 줄임
