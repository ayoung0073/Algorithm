# 우선순위큐

우선순위 큐(Priority Queue)는 들어간 순서에 상관없이 우선순위가 높은 데이터가 먼저 나오는 것을 말한다.<br>
우선순위 큐를 구현하는 방법은 3가지로 나뉜다.
1. 배열을 기반으로 구현
2. 연결리스트를 기반으로 구현
3. 힙(Heap)을 이용하여 구현
<br><br>

> 우선순위 큐는 보통 힙을 이용해서 구현하는 것이 일반적이다.
이유를 살펴보자.<br>
1. 배열을 이용하는 경우<br>
우선순위가 높은 순서대로 배열의 가장 앞부분부터 넣는다면, 우선순위가 높은 데이터를 반환하는 것은 맨 앞의 인덱스를 바로 이용하면 되므로 어렵지 않다.<br>
하지만 우선순위가 중간인 것이 들어가야 하는 **삽입 과정**에서는 뒤의 데이터까지 인덱스를 모두 한 칸씩 뒤로 밀어야 하는 **단점**이 있다.
최악의 경우 삽입해야 하는 위치를 찾기 위해 모든 인덱스를 탐색해야 한다. 
이때의 시간 복잡도는 O(n)이 된다. <br>
**→ 시간 복잡도 : 삭제는 O(1), 삽입은 O(n)**
2. 연결리스트를 이용하는 경우<br>
우선 순위가 높은 순서대로 연결을 시키면, 우선순위가 높은 데이터를 반환하는 것은 쉽다.<br>
하지만 연결리스트 또한 삽입의 과정 또한 배열과 마찬가지로 그 위치를 찾아야 한다.<br>
**→ 시간 복잡도 : 삭제는 O(1), 삽입은 O(n)**<br>
3. 힙을 이용하는 경우<br>
이진 트리의 높이가 하나 증가할 때마다 저장 가능한 자료의 개수는 2배 증가하며, 비교 연산 횟수는 1회 증가한다. 즉 삭제나 삽입 모두 최악의 경우에는 O(log2n) 의 시간 복잡도를 가진다. <br>
**→ 연결리스트로 구현 시 시간 복잡도 : 삭제는 O(log2n), 삽입은 O(log2n)**
<br><br>
이처럼 배열이나 연결 리스트가 삭제에서는 시간 복잡도의 우위를 점할지라도, 삽입의 시간 복잡도가 힙 기반이 월등하기 때문에, 편차가 심한 배열과 연결리스트보다는 힙으로 구현하는 것이다.

# 정렬

## 선택 정렬(selction sort)
- 우선순위 큐의 일종이다.
- 우선순위 큐를 **무순서리스트**로 구현한다.

```c
// 제자리 선택 정렬
void selection_sort(int list[], int n) // 배열과 배열원소 개수
{
    int least, temp;

    for (int i = 0 ; i < n - 1;i++)
    {
        least = i;
        for(int j = i + 1; j < n; j++)
            if(list[j] < list[least])
                least = j;
        SWAP(list[i], list[least], temp);
    }
}
```
- 전체 : O(n^2) 

## 삽입 정렬(insertion sort)
- 우선순위 큐의 일종이다.
- 우선순위 큐를 **순서리스트**로 구현한다.
```c
// 제자리 삽입 정렬
void insertion_sort(int list[], int n) // 배열과 배열원소 개수
{
    int i, j, save; 
    for (i = 1; i < n; i++)
    {
        save = list[i];
        for(j = i - 1; j >= 0 && list[j] > save; j--) // 비교 대상(save)이 더 클 때 for문 종료
            list[j + 1] = list[j];
        list[j + 1] = save;
    }
}
```
- 전체 : O(n^2)


## 버블 정렬(bubble sort)
```c
void bubble_sort(int list[], int n)
{
    int temp;
    // 마지막 숫자는 정렬된다.
    for (int i = n - 1; i >= 0; i--)
    {
        for (int j = 0; j < i; j++)
        {
            if (list[j] > list[j + 1])
                SWAP(list[j], list[j + 1], temp);
        }
    }
}
```
- 전체 : O(n^2)


## 쉘 정렬(shell sort)
- 삽입 정렬을 보완한 알고리즘
- 삽입 정렬이 어느 정도 정렬된 배열에 대해서는 대단히 빠른 것에 착안
- 삽입 정렬의 최대 문제점: 요소들이 삽입될 때, 이웃한 위치로만 이동한다.<br>
즉, 만약 삽입되어야 할 위치가 현재 위치에서 상당히 멀리 떨어진 곳이라면 많은 이동을 해야만 제자리로 갈 수 있다.<br>
삽입 정렬과 다르게 셸 정렬은 전체의 리스트를 한 번에 정렬하지 않는다.
- 과정 설명
    1. 먼저 정렬해야 할 리스트를 일정한 기준에 따라 분류
    2. 연속적이지 않은 여러 개의 부분 리스트를 생성
    3. 각 부분 리스트를 삽입 정렬을 이용하여 정렬
    4. 모든 부분 리스트가 정렬되면 다시 전체 리스트를 더 적은 개수의 부분 리스트로 만든 후에 알고리즘을 반복
    5. 위의 과정을 부분 리스트의 개수가 1이 될 때까지 반복


```c
void inc_insertion_sort(int list[], int first, int last, int gap) 
{
    int i, j, key; 
    for (i = first + gap; i <= last; i = i + gap) // 첫번째 원소는 이미 정렬되어있다고 가정
    {
        key = list[i];
        for(j = i - gap; j >= first && list[j] > key; j = j - gap) 
        // 기존 삽입 정렬에서는 j >= 0 이 조건 -> j >= first
            list[j + gap] = list[j];
        list[j + gap] = key;
    }
}

void shell_sort(int list[], int n)
{
    int i, gap;
    for (gap = n / 2; gap > 0; gap = gap / 2)
    {
        if (gap % 2 == 0) // 갭이 짝수인 경우, 홀수로 바꿔줌(성능 측)
            gap++;
        for(i = 0; i < gap; i++)
            inc_insertion_sort(list, i, n - 1, gap); // (배열, 첫번째 인덱스, 마지막 인덱스, 갭)
    }
}
```
